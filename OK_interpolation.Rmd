---
title: "Ordinary Kriging, Method of Moments (MoM)"
author: |
  Laura Delgado Bejarano  
  Agricultural Engineer, Universidad Nacional de Colombia  
  Masterâ€™s Candidate, University of Campinas (UNICAMP)
date: "2024-10-22"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# --- Directory settings (edit these paths as needed) ---
WORK_DIR <- "Project_route/"  # <- edit if needed
WORK_DIR <- normalizePath(WORK_DIR, winslash = "/", mustWork = TRUE)  # standardize slashes on Windows
knitr::opts_knit$set(root.dir = WORK_DIR)  # make this the working dir for all chunks


```

# Cleaning the space

```{r,cleaning}
rm(list = ls())   # Clear all objects
graphics.off()    # Close graphics devices
cat("\014")       # Clear console

```

# Libraries 
Installing and loading the libraries that are going to be used 

```{r,libraries,echo=T}
# Libraries: install if missing, then load
pkgs <- c(
  "sp", "gstat", "ggspatial", "raster", "ggplot2", "gridExtra",
  "ggstar", "mapview", "terra", "sf", "akima", "automap",
  "paletteer", "viridis", "hydroGOF","epiR"
)

# Install any missing packages (first run on a new machine)
to_install <- pkgs[!(pkgs %in% rownames(installed.packages()))]
if (length(to_install)) {
  install.packages(to_install, repos = "https://cloud.r-project.org")
}

# Load all required packages, suppressing startup messages
invisible(lapply(pkgs, function(p) {
  suppressPackageStartupMessages(library(p, character.only = TRUE))
}))

```


# Loading the data 

## Load polygon of the area of study

```{r,poly}
poly <- st_read(".../contour_area.shp") 
plot(poly)
poly_sf <- st_zm(poly)
```

## Create a clean and empty grid to interpolate 

```{r,grid}
# Create base raster at 5 m resolution and convert to grid
r  <- raster(poly_sf, res = 5)         # base grid resolution (meters)
rp <- rasterize(poly_sf, r, 0)         # empty raster within polygon
grid <- as(rp, "SpatialPixelsDataFrame")
plot(grid)

proj4string(grid) <-CRS("+init=epsg:32723") #CRS area
proj4string(grid)

```

## Load the csv with the data
Here is important to know if the csv are separed by , or ; and change it if necessary


```{r,1cada1_Argila}
#Load the complete dataframe
original = data.frame(read.csv(file = ".../dataset.csv",
                               header = TRUE, sep = ';'))
head(original)
dados = original[,c(7,8,6)] # select columns of interest (x,y,z)
head(dados)
dados = na.omit(dados)
names(dados) = c( "x", "y", "Z") # ensure names x, y, Z: variable to interpolate 
sp::coordinates(dados) = ~x+y 
sp::bubble(dados, "Z") 
```

## Geostatistics 
Adjust the experimental semivariogram, here is necessary to define the initial values based on the experimental semivariogram:  vgm(psill (c), model, range (a), nugget (co))

```{r,semivar}
# Build gstat object
# Here is important to change to the variable that is going to be interpolated 
g = gstat(formula = Z ~ 1, data=dados) 

# Distance helpers
print(max(dist(dados@coords))/2) #Cutoff - half of the max distance 
print(min(dist(dados@coords))) #Min distance to define the lags (width)
# Experimental variogram
var_exp = gstat::variogram(g, cutoff=905, width=80, cressie=F)
plot(var_exp)
var(dados$Z) # Data variance (should be close to variogram sill)


# Spherical model
fit.sph = fit.variogram(var_exp, vgm(c, "Sph", a, co)) 
plot(var_exp, fit.sph)

# Exponential model
fit.exp = fit.variogram(var_exp, vgm(c, "Exp", a, co)) 
plot(var_exp, fit.exp)

# Gaussian model
fit.gauss = fit.variogram(var_exp, vgm(c, "Gau", a, co)) 
plot(var_exp, fit.gauss) 

```

## LOOCV 
Cross validation to select the best fit model to krige, if is going to be a high density kriging (high number of samples as ECa or productivity) is necessary to add nfold=10 and nmax=200

```{r,cv}
# Spherical
xvalid.sph <- gstat::krige.cv(Z ~ 1, locations = dados, model = fit.sph)
lm_sph     <- lm(xvalid.sph$var1.pred ~ xvalid.sph$observed)
r2_sph     <- summary(lm_sph)$r.squared
rmse_sph   <- hydroGOF::rmse(xvalid.sph$var1.pred, xvalid.sph$observed)
slope_sph  <- lm_sph$coefficients[2]
ccc_sph    <- as.numeric(epiR::epi.ccc(xvalid.sph$var1.pred, xvalid.sph$observed)$rho.c["est"])

# Exponential 
xvalid.exp <- gstat::krige.cv(Z ~ 1, locations = dados, model = fit.exp)
lm_exp     <- lm(xvalid.exp$var1.pred ~ xvalid.exp$observed)
r2_exp     <- summary(lm_exp)$r.squared
rmse_exp   <- hydroGOF::rmse(xvalid.exp$var1.pred, xvalid.exp$observed)
slope_exp  <- lm_exp$coefficients[2]
ccc_exp    <- as.numeric(epiR::epi.ccc(xvalid.exp$var1.pred, xvalid.exp$observed)$rho.c["est"])

# Gaussian
xvalid.gau <- gstat::krige.cv(Z ~ 1, locations = dados, model = fit.gauss)
lm_gau     <- lm(xvalid.gau$var1.pred ~ xvalid.gau$observed)
r2_gau     <- summary(lm_gau)$r.squared
rmse_gau   <- hydroGOF::rmse(xvalid.gau$var1.pred, xvalid.gau$observed)
slope_gau  <- lm_gau$coefficients[2]
ccc_gau    <- as.numeric(epiR::epi.ccc(xvalid.gau$var1.pred, xvalid.gau$observed)$rho.c["est"])
```

Creating the metrics table 

```{r,cv table }
df.r2    <- data.frame(r2_sph, r2_exp, r2_gau)
df.rmse  <- data.frame(rmse_sph, rmse_exp, rmse_gau)
df.slope <- data.frame(slope_sph, slope_exp, slope_gau)
df.ccc   <- data.frame(ccc_sph, ccc_exp, ccc_gau)


temp <- data.frame(cbind(t(df.r2), t(df.rmse), t(df.slope), t(df.ccc)))
colnames(temp) <- c("R2", "RMSE", "Slope", "LCCC")

rnames <- gsub("r2_", "", rownames(temp))
rownames(temp) <- rnames

print(temp)
```

Taking theorical parameters - it has to change for the best model

```{r}
# Extract nugget, partial sill, total sill, and range
nugget        <- fit.gauss$psill[1]
partial_sill  <- fit.gauss$psill[2]
sill          <- partial_sill + nugget
range         <- fit.gauss$range[2]

# Spatial Dependence Index (SDI) as percentage of partial sill over total sill
SDI <- (partial_sill / sill) * 100

# Classify SDI into categories
Class <- ifelse(SDI < 20, "Very low",
         ifelse(SDI < 40, "Low",
         ifelse(SDI < 60, "Medium",
         ifelse(SDI < 80, "High", "Very high"))))

# Build summary table (note: mixing numeric and character will coerce to character)
table_params <- data.frame(
  Parameter = c("Nugget", "Sill", "Range", "SDI%", "Class"),
  Value     = c(nugget, sill, range, SDI, Class),
  stringsAsFactors = FALSE
)

table_params
```
#Kriging 

Doing the kriging with the selected model

```{r,ok}
# Kriging with the selected model
proj4string(dados) <- CRS("+init=epsg:32723")
proj4string(dados)

mapa = krige(Z ~ 1, dados, grid, model = fit.gauss)
plot(mapa)


```
Exporting the raster

```{r,export}
mapaRaster <- raster(mapa)

filename<-'.../Final_map.tiff'
writeRaster(mapaRaster, filename , format = 'GTiff', overwrite = T)
```

Graphic with ggplot

```{r,plotting,fig.width=7, fig.height=6}
ggplot() + 
  geom_raster(data = as.data.frame(mapa), aes(fill = var1.pred, x = x, y = y)) +
  scale_fill_viridis_c() +
    annotation_north_arrow(which_north = "grid",height = unit(1, "cm"),
                         width = unit(0.9, "cm"),
                         pad_x = unit(0.5, "cm"),
                         pad_y = unit(10, "cm"),
                         style=north_arrow_fancy_orienteering())+
  annotation_scale(location = "bl", width_hint = 0.2)+
  theme_bw()
```

